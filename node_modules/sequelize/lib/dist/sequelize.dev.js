"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;

var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};

var __spreadValues = function __spreadValues(a, b) {
  for (var prop in b || (b = {})) {
    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }

  if (__getOwnPropSymbols) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = __getOwnPropSymbols(b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return a;
};

var __spreadProps = function __spreadProps(a, b) {
  return __defProps(a, __getOwnPropDescs(b));
};

var url = require("url");

var path = require("path");

var pgConnectionString = require("pg-connection-string");

var retry = require("retry-as-promised");

var _ = require("lodash");

var Utils = require("./utils");

var Model = require("./model");

var DataTypes = require("./data-types");

var Deferrable = require("./deferrable");

var ModelManager = require("./model-manager");

var Transaction = require("./transaction");

var QueryTypes = require("./query-types");

var TableHints = require("./table-hints");

var IndexHints = require("./index-hints");

var sequelizeErrors = require("./errors");

var Hooks = require("./hooks");

var Association = require("./associations/index");

var Validator = require("./utils/validator-extras").validator;

var Op = require("./operators");

var deprecations = require("./utils/deprecations");

var _require = require("./dialects/abstract/query-interface"),
    QueryInterface = _require.QueryInterface;

var _require2 = require("./associations/belongs-to"),
    BelongsTo = _require2.BelongsTo;

var HasOne = require("./associations/has-one");

var _require3 = require("./associations/belongs-to-many"),
    BelongsToMany = _require3.BelongsToMany;

var _require4 = require("./associations/has-many"),
    HasMany = _require4.HasMany;

var Sequelize =
/*#__PURE__*/
function () {
  function Sequelize(database, username, password, options) {
    _classCallCheck(this, Sequelize);

    var config;

    if (arguments.length === 1 && _typeof(database) === "object") {
      options = database;
      config = _.pick(options, "host", "port", "database", "username", "password");
    } else if (arguments.length === 1 && typeof database === "string" || arguments.length === 2 && _typeof(username) === "object") {
      config = {};
      options = username || {};
      var urlParts = url.parse(arguments[0], true);
      options.dialect = urlParts.protocol.replace(/:$/, "");
      options.host = urlParts.hostname;

      if (options.dialect === "sqlite" && urlParts.pathname && !urlParts.pathname.startsWith("/:memory")) {
        var storagePath = path.join(options.host, urlParts.pathname);
        options.storage = path.resolve(options.storage || storagePath);
      }

      if (urlParts.pathname) {
        config.database = urlParts.pathname.replace(/^\//, "");
      }

      if (urlParts.port) {
        options.port = urlParts.port;
      }

      if (urlParts.auth) {
        var authParts = urlParts.auth.split(":");
        config.username = authParts[0];
        if (authParts.length > 1) config.password = authParts.slice(1).join(":");
      }

      if (urlParts.query) {
        if (urlParts.query.host) {
          options.host = urlParts.query.host;
        }

        if (options.dialectOptions) {
          Object.assign(options.dialectOptions, urlParts.query);
        } else {
          options.dialectOptions = urlParts.query;

          if (urlParts.query.options) {
            try {
              var o = JSON.parse(urlParts.query.options);
              options.dialectOptions.options = o;
            } catch (e) {}
          }
        }
      }

      if (["postgres", "postgresql"].includes(options.dialect)) {
        Object.assign(options.dialectOptions, pgConnectionString.parse(arguments[0]));
      }
    } else {
      options = options || {};
      config = {
        database: database,
        username: username,
        password: password
      };
    }

    Sequelize.runHooks("beforeInit", config, options);
    this.options = __spreadValues({
      dialect: null,
      dialectModule: null,
      dialectModulePath: null,
      host: "localhost",
      protocol: "tcp",
      define: {},
      query: {},
      sync: {},
      timezone: "+00:00",
      standardConformingStrings: true,
      logging: console.log,
      omitNull: false,
      "native": false,
      replication: false,
      ssl: void 0,
      pool: {},
      quoteIdentifiers: true,
      hooks: {},
      retry: {
        max: 5,
        match: ["SQLITE_BUSY: database is locked"]
      },
      transactionType: Transaction.TYPES.DEFERRED,
      isolationLevel: null,
      databaseVersion: 0,
      typeValidation: false,
      benchmark: false,
      minifyAliases: false,
      logQueryParameters: false
    }, options);

    if (!this.options.dialect) {
      throw new Error("Dialect needs to be explicitly supplied as of v4.0.0");
    }

    if (this.options.dialect === "postgresql") {
      this.options.dialect = "postgres";
    }

    if (this.options.dialect === "sqlite" && this.options.timezone !== "+00:00") {
      throw new Error("Setting a custom timezone is not supported by SQLite, dates are always returned as UTC. Please remove the custom timezone parameter.");
    }

    if (this.options.logging === true) {
      deprecations.noTrueLogging();
      this.options.logging = console.log;
    }

    this._setupHooks(options.hooks);

    this.config = {
      database: config.database || this.options.database,
      username: config.username || this.options.username,
      password: config.password || this.options.password || null,
      host: config.host || this.options.host,
      port: config.port || this.options.port,
      pool: this.options.pool,
      protocol: this.options.protocol,
      "native": this.options["native"],
      ssl: this.options.ssl,
      replication: this.options.replication,
      dialectModule: this.options.dialectModule,
      dialectModulePath: this.options.dialectModulePath,
      keepDefaultTimezone: this.options.keepDefaultTimezone,
      dialectOptions: this.options.dialectOptions
    };
    var Dialect;

    switch (this.getDialect()) {
      case "mariadb":
        Dialect = require("./dialects/mariadb");
        break;

      case "mssql":
        Dialect = require("./dialects/mssql");
        break;

      case "mysql":
        Dialect = require("./dialects/mysql");
        break;

      case "postgres":
        Dialect = require("./dialects/postgres");
        break;

      case "sqlite":
        Dialect = require("./dialects/sqlite");
        break;

      case "db2":
        Dialect = require("./dialects/db2");
        break;

      case "snowflake":
        Dialect = require("./dialects/snowflake");
        break;

      default:
        throw new Error("The dialect ".concat(this.getDialect(), " is not supported. Supported dialects: mssql, mariadb, mysql, postgres, db2 and sqlite."));
    }

    this.dialect = new Dialect(this);
    this.dialect.queryGenerator.typeValidation = options.typeValidation;

    if (_.isPlainObject(this.options.operatorsAliases)) {
      deprecations.noStringOperators();
      this.dialect.queryGenerator.setOperatorsAliases(this.options.operatorsAliases);
    } else if (typeof this.options.operatorsAliases === "boolean") {
      deprecations.noBoolOperatorAliases();
    }

    this.queryInterface = this.dialect.queryInterface;
    this.models = {};
    this.modelManager = new ModelManager(this);
    this.connectionManager = this.dialect.connectionManager;
    Sequelize.runHooks("afterInit", this);
  }

  _createClass(Sequelize, [{
    key: "refreshTypes",
    value: function refreshTypes() {
      this.connectionManager.refreshTypeParser(DataTypes);
    }
  }, {
    key: "getDialect",
    value: function getDialect() {
      return this.options.dialect;
    }
  }, {
    key: "getDatabaseName",
    value: function getDatabaseName() {
      return this.config.database;
    }
  }, {
    key: "getQueryInterface",
    value: function getQueryInterface() {
      return this.queryInterface;
    }
  }, {
    key: "define",
    value: function define(modelName, attributes) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      options.modelName = modelName;
      options.sequelize = this;

      var model =
      /*#__PURE__*/
      function (_Model) {
        _inherits(model, _Model);

        function model() {
          _classCallCheck(this, model);

          return _possibleConstructorReturn(this, _getPrototypeOf(model).apply(this, arguments));
        }

        return model;
      }(Model);

      model.init(attributes, options);
      return model;
    }
  }, {
    key: "model",
    value: function model(modelName) {
      if (!this.isDefined(modelName)) {
        throw new Error("".concat(modelName, " has not been defined"));
      }

      return this.modelManager.getModel(modelName);
    }
  }, {
    key: "isDefined",
    value: function isDefined(modelName) {
      return !!this.modelManager.models.find(function (model) {
        return model.name === modelName;
      });
    }
  }, {
    key: "query",
    value: function query(sql, options) {
      var _this = this;

      var bindParameters, _this$dialect$Query$f, _this$dialect$Query$f2, checkTransaction, retryOptions;

      return regeneratorRuntime.async(function query$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              options = __spreadValues(__spreadValues({}, this.options.query), options);

              if (options.instance && !options.model) {
                options.model = options.instance.constructor;
              }

              if (!options.instance && !options.model) {
                options.raw = true;
              }

              if (options.mapToModel) {
                options.fieldMap = _.get(options, "model.fieldAttributeMap", {});
              }

              options = _.defaults(options, {
                logging: Object.prototype.hasOwnProperty.call(this.options, "logging") ? this.options.logging : console.log,
                searchPath: Object.prototype.hasOwnProperty.call(this.options, "searchPath") ? this.options.searchPath : "DEFAULT"
              });

              if (!options.type) {
                if (options.model || options.nest || options.plain) {
                  options.type = QueryTypes.SELECT;
                } else {
                  options.type = QueryTypes.RAW;
                }
              }

              if (!this.dialect.supports.searchPath || !this.options.dialectOptions || !this.options.dialectOptions.prependSearchPath || options.supportsSearchPath === false) {
                delete options.searchPath;
              } else if (!options.searchPath) {
                options.searchPath = "DEFAULT";
              }

              if (!(_typeof(sql) === "object")) {
                _context2.next = 17;
                break;
              }

              if (!(sql.values !== void 0)) {
                _context2.next = 12;
                break;
              }

              if (!(options.replacements !== void 0)) {
                _context2.next = 11;
                break;
              }

              throw new Error("Both `sql.values` and `options.replacements` cannot be set at the same time");

            case 11:
              options.replacements = sql.values;

            case 12:
              if (!(sql.bind !== void 0)) {
                _context2.next = 16;
                break;
              }

              if (!(options.bind !== void 0)) {
                _context2.next = 15;
                break;
              }

              throw new Error("Both `sql.bind` and `options.bind` cannot be set at the same time");

            case 15:
              options.bind = sql.bind;

            case 16:
              if (sql.query !== void 0) {
                sql = sql.query;
              }

            case 17:
              sql = sql.trim();

              if (!(options.replacements && options.bind)) {
                _context2.next = 20;
                break;
              }

              throw new Error("Both `replacements` and `bind` cannot be set at the same time");

            case 20:
              if (options.replacements) {
                if (Array.isArray(options.replacements)) {
                  sql = Utils.format([sql].concat(options.replacements), this.options.dialect);
                } else {
                  sql = Utils.formatNamedParameters(sql, options.replacements, this.options.dialect);
                }
              }

              if (options.bind) {
                _this$dialect$Query$f = this.dialect.Query.formatBindParameters(sql, options.bind, this.options.dialect);
                _this$dialect$Query$f2 = _slicedToArray(_this$dialect$Query$f, 2);
                sql = _this$dialect$Query$f2[0];
                bindParameters = _this$dialect$Query$f2[1];
              }

              checkTransaction = function checkTransaction() {
                if (options.transaction && options.transaction.finished && !options.completesTransaction) {
                  var error = new Error("".concat(options.transaction.finished, " has been called on this transaction(").concat(options.transaction.id, "), you can no longer use it. (The rejected query is attached as the 'sql' property of this error)"));
                  error.sql = sql;
                  throw error;
                }
              };

              retryOptions = __spreadValues(__spreadValues({}, this.options.retry), options.retry);
              return _context2.abrupt("return", retry(function _callee() {
                var connection, query;
                return regeneratorRuntime.async(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (options.transaction === void 0 && Sequelize._cls) {
                          options.transaction = Sequelize._cls.get("transaction");
                        }

                        checkTransaction();
                        _context.next = 4;
                        return regeneratorRuntime.awrap(options.transaction ? options.transaction.connection : _this.connectionManager.getConnection(options));

                      case 4:
                        connection = _context.sent;

                        if (_this.options.dialect === "db2" && options.alter) {
                          if (options.alter.drop === false) {
                            connection.dropTable = false;
                          }
                        }

                        query = new _this.dialect.Query(connection, _this, options);
                        _context.prev = 7;
                        _context.next = 10;
                        return regeneratorRuntime.awrap(_this.runHooks("beforeQuery", options, query));

                      case 10:
                        checkTransaction();
                        _context.next = 13;
                        return regeneratorRuntime.awrap(query.run(sql, bindParameters));

                      case 13:
                        return _context.abrupt("return", _context.sent);

                      case 14:
                        _context.prev = 14;
                        _context.next = 17;
                        return regeneratorRuntime.awrap(_this.runHooks("afterQuery", options, query));

                      case 17:
                        if (options.transaction) {
                          _context.next = 20;
                          break;
                        }

                        _context.next = 20;
                        return regeneratorRuntime.awrap(_this.connectionManager.releaseConnection(connection));

                      case 20:
                        return _context.finish(14);

                      case 21:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, null, null, [[7,, 14, 21]]);
              }, retryOptions));

            case 25:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "set",
    value: function set(variables, options) {
      var query;
      return regeneratorRuntime.async(function set$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              options = __spreadValues(__spreadValues({}, this.options.set), _typeof(options) === "object" && options);

              if (["mysql", "mariadb"].includes(this.options.dialect)) {
                _context3.next = 3;
                break;
              }

              throw new Error("sequelize.set is only supported for mysql or mariadb");

            case 3:
              if (!(!options.transaction || !(options.transaction instanceof Transaction))) {
                _context3.next = 5;
                break;
              }

              throw new TypeError("options.transaction is required");

            case 5:
              options.raw = true;
              options.plain = true;
              options.type = "SET";
              query = "SET ".concat(_.map(variables, function (v, k) {
                return "@".concat(k, " := ").concat(typeof v === "string" ? "\"".concat(v, "\"") : v);
              }).join(", "));
              _context3.next = 11;
              return regeneratorRuntime.awrap(this.query(query, options));

            case 11:
              return _context3.abrupt("return", _context3.sent);

            case 12:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "escape",
    value: function escape(value) {
      return this.dialect.queryGenerator.escape(value);
    }
  }, {
    key: "createSchema",
    value: function createSchema(schema, options) {
      return regeneratorRuntime.async(function createSchema$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return regeneratorRuntime.awrap(this.getQueryInterface().createSchema(schema, options));

            case 2:
              return _context4.abrupt("return", _context4.sent);

            case 3:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "showAllSchemas",
    value: function showAllSchemas(options) {
      return regeneratorRuntime.async(function showAllSchemas$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return regeneratorRuntime.awrap(this.getQueryInterface().showAllSchemas(options));

            case 2:
              return _context5.abrupt("return", _context5.sent);

            case 3:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "dropSchema",
    value: function dropSchema(schema, options) {
      return regeneratorRuntime.async(function dropSchema$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return regeneratorRuntime.awrap(this.getQueryInterface().dropSchema(schema, options));

            case 2:
              return _context6.abrupt("return", _context6.sent);

            case 3:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "dropAllSchemas",
    value: function dropAllSchemas(options) {
      return regeneratorRuntime.async(function dropAllSchemas$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return regeneratorRuntime.awrap(this.getQueryInterface().dropAllSchemas(options));

            case 2:
              return _context7.abrupt("return", _context7.sent);

            case 3:
            case "end":
              return _context7.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "sync",
    value: function sync(options) {
      var models, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, model;

      return regeneratorRuntime.async(function sync$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              options = __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, this.options), this.options.sync), options), {
                hooks: options ? options.hooks !== false : true
              });

              if (!options.match) {
                _context8.next = 4;
                break;
              }

              if (options.match.test(this.config.database)) {
                _context8.next = 4;
                break;
              }

              throw new Error("Database \"".concat(this.config.database, "\" does not match sync match parameter \"").concat(options.match, "\""));

            case 4:
              if (!options.hooks) {
                _context8.next = 7;
                break;
              }

              _context8.next = 7;
              return regeneratorRuntime.awrap(this.runHooks("beforeBulkSync", options));

            case 7:
              if (!options.force) {
                _context8.next = 10;
                break;
              }

              _context8.next = 10;
              return regeneratorRuntime.awrap(this.drop(options));

            case 10:
              models = [];
              this.modelManager.forEachModel(function (model) {
                if (model) {
                  models.push(model);
                } else {}
              });

              if (models.length) {
                _context8.next = 17;
                break;
              }

              _context8.next = 15;
              return regeneratorRuntime.awrap(this.authenticate(options));

            case 15:
              _context8.next = 43;
              break;

            case 17:
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context8.prev = 20;
              _iterator2 = models[Symbol.iterator]();

            case 22:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context8.next = 29;
                break;
              }

              model = _step2.value;
              _context8.next = 26;
              return regeneratorRuntime.awrap(model.sync(options));

            case 26:
              _iteratorNormalCompletion2 = true;
              _context8.next = 22;
              break;

            case 29:
              _context8.next = 35;
              break;

            case 31:
              _context8.prev = 31;
              _context8.t0 = _context8["catch"](20);
              _didIteratorError2 = true;
              _iteratorError2 = _context8.t0;

            case 35:
              _context8.prev = 35;
              _context8.prev = 36;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 38:
              _context8.prev = 38;

              if (!_didIteratorError2) {
                _context8.next = 41;
                break;
              }

              throw _iteratorError2;

            case 41:
              return _context8.finish(38);

            case 42:
              return _context8.finish(35);

            case 43:
              if (!options.hooks) {
                _context8.next = 46;
                break;
              }

              _context8.next = 46;
              return regeneratorRuntime.awrap(this.runHooks("afterBulkSync", options));

            case 46:
              return _context8.abrupt("return", this);

            case 47:
            case "end":
              return _context8.stop();
          }
        }
      }, null, this, [[20, 31, 35, 43], [36,, 38, 42]]);
    }
  }, {
    key: "truncate",
    value: function truncate(options) {
      var models, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, model;

      return regeneratorRuntime.async(function truncate$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              models = [];
              this.modelManager.forEachModel(function (model) {
                if (model) {
                  models.push(model);
                }
              }, {
                reverse: false
              });

              if (!(options && options.cascade)) {
                _context9.next = 31;
                break;
              }

              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context9.prev = 6;
              _iterator3 = models[Symbol.iterator]();

            case 8:
              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
                _context9.next = 15;
                break;
              }

              model = _step3.value;
              _context9.next = 12;
              return regeneratorRuntime.awrap(model.truncate(options));

            case 12:
              _iteratorNormalCompletion3 = true;
              _context9.next = 8;
              break;

            case 15:
              _context9.next = 21;
              break;

            case 17:
              _context9.prev = 17;
              _context9.t0 = _context9["catch"](6);
              _didIteratorError3 = true;
              _iteratorError3 = _context9.t0;

            case 21:
              _context9.prev = 21;
              _context9.prev = 22;

              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }

            case 24:
              _context9.prev = 24;

              if (!_didIteratorError3) {
                _context9.next = 27;
                break;
              }

              throw _iteratorError3;

            case 27:
              return _context9.finish(24);

            case 28:
              return _context9.finish(21);

            case 29:
              _context9.next = 33;
              break;

            case 31:
              _context9.next = 33;
              return regeneratorRuntime.awrap(Promise.all(models.map(function (model) {
                return model.truncate(options);
              })));

            case 33:
            case "end":
              return _context9.stop();
          }
        }
      }, null, this, [[6, 17, 21, 29], [22,, 24, 28]]);
    }
  }, {
    key: "drop",
    value: function drop(options) {
      var models, _i2, _models, model;

      return regeneratorRuntime.async(function drop$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              models = [];
              this.modelManager.forEachModel(function (model) {
                if (model) {
                  models.push(model);
                }
              }, {
                reverse: false
              });
              _i2 = 0, _models = models;

            case 3:
              if (!(_i2 < _models.length)) {
                _context10.next = 10;
                break;
              }

              model = _models[_i2];
              _context10.next = 7;
              return regeneratorRuntime.awrap(model.drop(options));

            case 7:
              _i2++;
              _context10.next = 3;
              break;

            case 10:
            case "end":
              return _context10.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "authenticate",
    value: function authenticate(options) {
      return regeneratorRuntime.async(function authenticate$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              options = __spreadValues({
                raw: true,
                plain: true,
                type: QueryTypes.SELECT
              }, options);
              _context11.next = 3;
              return regeneratorRuntime.awrap(this.query("SELECT 1+1 AS result", options));

            case 3:
              return _context11.abrupt("return");

            case 4:
            case "end":
              return _context11.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "databaseVersion",
    value: function databaseVersion(options) {
      return regeneratorRuntime.async(function databaseVersion$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return regeneratorRuntime.awrap(this.getQueryInterface().databaseVersion(options));

            case 2:
              return _context12.abrupt("return", _context12.sent);

            case 3:
            case "end":
              return _context12.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "random",
    value: function random() {
      if (["postgres", "sqlite", "snowflake"].includes(this.getDialect())) {
        return this.fn("RANDOM");
      }

      return this.fn("RAND");
    }
  }, {
    key: "transaction",
    value: function transaction(options, autoCallback) {
      var transaction;
      return regeneratorRuntime.async(function transaction$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              if (typeof options === "function") {
                autoCallback = options;
                options = void 0;
              }

              transaction = new Transaction(this, options);

              if (autoCallback) {
                _context14.next = 6;
                break;
              }

              _context14.next = 5;
              return regeneratorRuntime.awrap(transaction.prepareEnvironment(false));

            case 5:
              return _context14.abrupt("return", transaction);

            case 6:
              return _context14.abrupt("return", Sequelize._clsRun(function _callee2() {
                var result;
                return regeneratorRuntime.async(function _callee2$(_context13) {
                  while (1) {
                    switch (_context13.prev = _context13.next) {
                      case 0:
                        _context13.prev = 0;
                        _context13.next = 3;
                        return regeneratorRuntime.awrap(transaction.prepareEnvironment());

                      case 3:
                        _context13.next = 5;
                        return regeneratorRuntime.awrap(autoCallback(transaction));

                      case 5:
                        result = _context13.sent;
                        _context13.next = 8;
                        return regeneratorRuntime.awrap(transaction.commit());

                      case 8:
                        _context13.next = 10;
                        return regeneratorRuntime.awrap(result);

                      case 10:
                        return _context13.abrupt("return", _context13.sent);

                      case 13:
                        _context13.prev = 13;
                        _context13.t0 = _context13["catch"](0);
                        _context13.prev = 15;

                        if (transaction.finished) {
                          _context13.next = 21;
                          break;
                        }

                        _context13.next = 19;
                        return regeneratorRuntime.awrap(transaction.rollback());

                      case 19:
                        _context13.next = 23;
                        break;

                      case 21:
                        _context13.next = 23;
                        return regeneratorRuntime.awrap(transaction.cleanup());

                      case 23:
                        _context13.next = 27;
                        break;

                      case 25:
                        _context13.prev = 25;
                        _context13.t1 = _context13["catch"](15);

                      case 27:
                        throw _context13.t0;

                      case 28:
                      case "end":
                        return _context13.stop();
                    }
                  }
                }, null, null, [[0, 13], [15, 25]]);
              }));

            case 7:
            case "end":
              return _context14.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "log",
    value: function log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var options;

      var last = _.last(args);

      if (last && _.isPlainObject(last) && Object.prototype.hasOwnProperty.call(last, "logging")) {
        options = last;

        if (options.logging === console.log) {
          args.splice(args.length - 1, 1);
        }
      } else {
        options = this.options;
      }

      if (options.logging) {
        var _options;

        if (options.logging === true) {
          deprecations.noTrueLogging();
          options.logging = console.log;
        }

        if ((this.options.benchmark || options.benchmark) && options.logging === console.log) {
          args = ["".concat(args[0], " Elapsed time: ").concat(args[1], "ms")];
        }

        (_options = options).logging.apply(_options, _toConsumableArray(args));
      }
    }
  }, {
    key: "close",
    value: function close() {
      return this.connectionManager.close();
    }
  }, {
    key: "normalizeDataType",
    value: function normalizeDataType(Type) {
      var type = typeof Type === "function" ? new Type() : Type;
      var dialectTypes = this.dialect.DataTypes || {};

      if (dialectTypes[type.key]) {
        type = dialectTypes[type.key].extend(type);
      }

      if (type instanceof DataTypes.ARRAY) {
        if (!type.type) {
          throw new Error("ARRAY is missing type definition for its values.");
        }

        if (dialectTypes[type.type.key]) {
          type.type = dialectTypes[type.type.key].extend(type.type);
        }
      }

      return type;
    }
  }, {
    key: "normalizeAttribute",
    value: function normalizeAttribute(attribute) {
      if (!_.isPlainObject(attribute)) {
        attribute = {
          type: attribute
        };
      }

      if (!attribute.type) return attribute;
      attribute.type = this.normalizeDataType(attribute.type);

      if (Object.prototype.hasOwnProperty.call(attribute, "defaultValue")) {
        if (typeof attribute.defaultValue === "function" && [DataTypes.NOW, DataTypes.UUIDV1, DataTypes.UUIDV4].includes(attribute.defaultValue)) {
          attribute.defaultValue = new attribute.defaultValue();
        }
      }

      if (attribute.type instanceof DataTypes.ENUM) {
        if (attribute.values) {
          attribute.type.values = attribute.type.options.values = attribute.values;
        } else {
          attribute.values = attribute.type.values;
        }

        if (!attribute.values.length) {
          throw new Error("Values for ENUM have not been defined.");
        }
      }

      return attribute;
    }
  }], [{
    key: "fn",
    value: function fn(_fn) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return new Utils.Fn(_fn, args);
    }
  }, {
    key: "col",
    value: function col(_col) {
      return new Utils.Col(_col);
    }
  }, {
    key: "cast",
    value: function cast(val, type) {
      return new Utils.Cast(val, type);
    }
  }, {
    key: "literal",
    value: function literal(val) {
      return new Utils.Literal(val);
    }
  }, {
    key: "and",
    value: function and() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return _defineProperty({}, Op.and, args);
    }
  }, {
    key: "or",
    value: function or() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return _defineProperty({}, Op.or, args);
    }
  }, {
    key: "json",
    value: function json(conditionsOrPath, value) {
      return new Utils.Json(conditionsOrPath, value);
    }
  }, {
    key: "where",
    value: function where(attr, comparator, logic) {
      return new Utils.Where(attr, comparator, logic);
    }
  }, {
    key: "useCLS",
    value: function useCLS(ns) {
      if (!ns || _typeof(ns) !== "object" || typeof ns.bind !== "function" || typeof ns.run !== "function") throw new Error("Must provide CLS namespace");
      Sequelize._cls = ns;
      return this;
    }
  }, {
    key: "_clsRun",
    value: function _clsRun(fn) {
      var ns = Sequelize._cls;
      if (!ns) return fn();
      var res;
      ns.run(function (context) {
        return res = fn(context);
      });
      return res;
    }
  }]);

  return Sequelize;
}();

Sequelize.prototype.fn = Sequelize.fn;
Sequelize.prototype.col = Sequelize.col;
Sequelize.prototype.cast = Sequelize.cast;
Sequelize.prototype.literal = Sequelize.literal;
Sequelize.prototype.and = Sequelize.and;
Sequelize.prototype.or = Sequelize.or;
Sequelize.prototype.json = Sequelize.json;
Sequelize.prototype.where = Sequelize.where;
Sequelize.prototype.validate = Sequelize.prototype.authenticate;
Object.defineProperty(Sequelize, "version", {
  enumerable: true,
  get: function get() {
    return require("../package.json").version;
  }
});
Sequelize.options = {
  hooks: {}
};
Sequelize.Utils = Utils;
Sequelize.Op = Op;
Sequelize.TableHints = TableHints;
Sequelize.IndexHints = IndexHints;
Sequelize.Transaction = Transaction;
Sequelize.prototype.Sequelize = Sequelize;
Sequelize.prototype.QueryTypes = Sequelize.QueryTypes = QueryTypes;
Sequelize.prototype.Validator = Sequelize.Validator = Validator;
Sequelize.Model = Model;
Sequelize.QueryInterface = QueryInterface;
Sequelize.BelongsTo = BelongsTo;
Sequelize.HasOne = HasOne;
Sequelize.HasMany = HasMany;
Sequelize.BelongsToMany = BelongsToMany;
Sequelize.DataTypes = DataTypes;

for (var dataType in DataTypes) {
  Sequelize[dataType] = DataTypes[dataType];
}

Sequelize.Deferrable = Deferrable;
Sequelize.prototype.Association = Sequelize.Association = Association;
Sequelize.useInflection = Utils.useInflection;
Hooks.applyTo(Sequelize);
Hooks.applyTo(Sequelize.prototype);
Sequelize.Error = sequelizeErrors.BaseError;

for (var _i3 = 0, _Object$keys = Object.keys(sequelizeErrors); _i3 < _Object$keys.length; _i3++) {
  var error = _Object$keys[_i3];
  Sequelize[error] = sequelizeErrors[error];
}

module.exports = Sequelize;
module.exports.Sequelize = Sequelize;
module.exports["default"] = Sequelize;